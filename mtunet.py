# -*- coding: utf-8 -*-
"""mtunet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17HKxjvGX2YpeFOH7YVIHhGWZq-0nMYDq
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import timm
from .blocks import ConvBNReLU, UpBlock, FiLM

class MTUNet(nn.Module):
    def __init__(self, in_ch=1, num_classes=6, seg_classes=1, encoder_name="tf_efficientnetv2_s"):
        """
        num_classes includes 5 hemorrhage subtypes and normal
        seg_classes is binary mask per slice or per subtype if multi label
        """
        super().__init__()
        self.num_classes = num_classes
        self.seg_classes = seg_classes

        # encoder
        self.encoder = timm.create_model(encoder_name, features_only=True, in_chans=in_ch, pretrained=False)
        chs = self.encoder.feature_info.channels()  # e.g. [24, 48, 64, 160, 256]
        self.stem = nn.Conv2d(in_ch, chs[0], 3, 1, 1)

        # decoder
        self.dec4 = UpBlock(chs[4], chs[3], 256, use_attn=True)
        self.dec3 = UpBlock(256,     chs[2], 128, use_attn=True)
        self.dec2 = UpBlock(128,     chs[1], 96,  use_attn=True)
        self.dec1 = UpBlock(96,      chs[0], 64,  use_attn=False)
        self.out_seg = nn.Conv2d(64, seg_classes, 1)

        # classification head on top of encoder last feature
        self.gap = nn.AdaptiveAvgPool2d(1)
        self.cls_head = nn.Sequential(
            nn.Conv2d(chs[4], 256, 1),
            nn.ReLU(inplace=True),
            nn.Flatten(),
            nn.Linear(256, num_classes)
        )

        # FiLM modulators at two decoder scales
        self.film4 = FiLM(num_classes, 256)
        self.film3 = FiLM(num_classes, 128)
        self.film2 = FiLM(num_classes, 96)
        self.film1 = FiLM(num_classes, 64)

    def forward(self, x):
        # encoder
        feats = self.encoder(x)  # list of 5
        c0, c1, c2, c3, c4 = feats

        # classification logits from deepest feature
        cls_logits = self.cls_head(self.gap(c4))

        # decoder with class guided FiLM
        d4 = self.dec4(c4, c3)
        d4 = self.film4(d4, cls_logits)

        d3 = self.dec3(d4, c2)
        d3 = self.film3(d3, cls_logits)

        d2 = self.dec2(d3, c1)
        d2 = self.film2(d2, cls_logits)

        d1 = self.dec1(d2, c0)
        d1 = self.film1(d1, cls_logits)

        seg = self.out_seg(d1)
        return cls_logits, seg